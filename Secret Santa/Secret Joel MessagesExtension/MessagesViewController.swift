//
//  MessagesViewController.swift
//  Secret Joel MessagesExtension
//
//  Created by Ian Costello on 12/20/18.
//  Copyright Â© 2018 Bridge. All rights reserved.
//

import UIKit
import Messages

extension UITextField {
    func setLeftPaddingPoints(_ amount:CGFloat){
        let paddingView = UIView(frame: CGRect(x: 0, y: 0, width: amount, height: self.frame.size.height))
        self.leftView = paddingView
        self.leftViewMode = .always
    }
    func setRightPaddingPoints(_ amount:CGFloat) {
        let paddingView = UIView(frame: CGRect(x: 0, y: 0, width: amount, height: self.frame.size.height))
        self.rightView = paddingView
        self.rightViewMode = .always
    }
}

class MessagesViewController: MSMessagesAppViewController, CompactDelegate, ExpandedDelegate, JoinDelegate, ResultsDelegate {
    let compactID:String = "compact"
    let expandedID:String = "expanded"
    let canJoinID:String = "join"
    let joinedID:String = "joined"
    let resultsID:String = "results"
    
    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.
    }
    
    // MARK: - Conversation Handling
    
    override func willBecomeActive(with conversation: MSConversation) {
        // Called when the extension is about to move from the inactive to active state.
        // This will happen when the extension is about to present UI.
        
        // Use this method to configure the extension and restore previously stored state.
    }
    
    override func didBecomeActive(with conversation: MSConversation) {
        presentVC(presentationStyle: self.presentationStyle)
    }
    
    override func didResignActive(with conversation: MSConversation) {
        // Called when the extension is about to move from the active to inactive state.
        // This will happen when the user dissmises the extension, changes to a different
        // conversation or quits Messages.
        
        // Use this method to release shared resources, save user data, invalidate timers,
        // and store enough state information to restore your extension to its current state
        // in case it is terminated later.
    }
   
    override func didReceive(_ message: MSMessage, conversation: MSConversation) {
        // Called when a message arrives that was generated by another instance of this
        // extension on a remote device.
        
        // Use this method to trigger UI updates in response to the message.
    }
    
    override func didStartSending(_ message: MSMessage, conversation: MSConversation) {
        // Called when the user taps the send button.
    }
    
    override func didCancelSending(_ message: MSMessage, conversation: MSConversation) {
        // Called when the user deletes the message without sending it.
    
        // Use this to clean up state related to the deleted message.
    }
    
    override func willTransition(to presentationStyle: MSMessagesAppPresentationStyle) {
        // Called before the extension transitions to a new presentation style.
    
        // Use this method to prepare for the change in presentation style.
    }
    
    func presentVC(presentationStyle:MSMessagesAppPresentationStyle) {
        var identifier:String = ""
        var url:URL? = nil
        
        let user:String = self.activeConversation?.localParticipantIdentifier.uuidString ?? "Unknown"
        
        if presentationStyle == .compact {
            identifier = compactID
        }
        else {
            if let tempURL = self.activeConversation?.selectedMessage?.url {
                url = tempURL
                let urlContents = parseURL()
                let components = URLComponents(url: url!, resolvingAgainstBaseURL: false)!
                for item in components.queryItems! {
                    if item.name == user && user != "Unknown" {
                        identifier = joinedID
                    }
                }
                if String(urlContents!.count - 3) == urlContents!["groupSize"] {
                    identifier = resultsID
                }
                if identifier == "" {
                    identifier = canJoinID
                }
            }
            else {
                identifier = expandedID
            }
        }
        let controller = storyboard?.instantiateViewController(withIdentifier: identifier)
        
        for child in children {
            child.willMove(toParent: nil)
            child.view.removeFromSuperview()
            child.removeFromParent()
        }
        
        addChild(controller!)
        
        controller!.view.frame = view.bounds
        controller!.view.translatesAutoresizingMaskIntoConstraints = false
        view.addSubview(controller!.view)
        
        controller!.view.leftAnchor.constraint(equalTo: view.leftAnchor).isActive = true
        controller!.view.rightAnchor.constraint(equalTo: view.rightAnchor).isActive = true
        controller!.view.topAnchor.constraint(equalTo: view.topAnchor).isActive = true
        controller!.view.bottomAnchor.constraint(equalTo: view.bottomAnchor).isActive = true
        
        controller?.didMove(toParent: self)
        
        if let compact = controller as? CompactViewController {
            compact.delegate = self as CompactDelegate
        }
        else if let expanded = controller as? ExpandedViewController {
            expanded.delegate = self as ExpandedDelegate
        }
        else if let join = controller as? JoinViewController {
            join.delegate = self as JoinDelegate
        }
        else if let results = controller as? ResultsViewController {
            results.delegate = self as ResultsDelegate
        }

    }
    
    override func didTransition(to presentationStyle: MSMessagesAppPresentationStyle) {
        // Called after the extension transitions to a new presentation style.
    
        // Use this method to finalize any behaviors associated with the change in presentation style.
        presentVC(presentationStyle: presentationStyle)
    }
    
    func startGroup() {
        requestPresentationStyle(.expanded)
    }
    
    func sendInvite(groupName: String, groupSize: Int, date: String, organizerName: String) {
        let session = self.activeConversation?.selectedMessage?.session ?? MSSession()
        let message = MSMessage(session: session)
        let layout = MSMessageTemplateLayout()
        layout.caption = "Tap to join " + groupName
        layout.subcaption = "1/\(groupSize) Group Members Joined"
        message.layout = layout
        
        let user:String = self.activeConversation?.localParticipantIdentifier.uuidString ?? "Unknown"
        message.url = getMessageURL(groupName: groupName, groupSize: groupSize, date: date, userID: user, name: organizerName)
        self.activeConversation?.insert(message, completionHandler: { (e:Error?) in print("complete!") })
        self.dismiss()
    }
    
    // Deprecated URL builder; could be done more elegantly
    func getMessageURL(groupName: String, groupSize: Int, date: String, userID: String, name: String) -> URL {
        var components = URLComponents()
        let qGroupName = URLQueryItem(name: "groupName", value: groupName)
        let qGroupSize = URLQueryItem(name: "groupSize", value: String(groupSize))

        let qDate = URLQueryItem(name: "date", value: date)
        let qSender = URLQueryItem(name: userID, value: name)
        components.queryItems = [qGroupName,qGroupSize,qDate,qSender]
        return components.url!
    }
    
 
    func separateName(nameList: String) -> [String] {
        var user = ""
        var name = ""
        var parsingUser = true
        var result = Array<String>()
        for character in nameList {
            if parsingUser && character == ":" {
                parsingUser = false
            }
            else if parsingUser {
                user += String(character)
            }
            else {
                name += String(character)
            }
        }
        result = [user, name]
        return result
    }
 
    func joinGroup(url: URL, joinName: String) {
        let session = self.activeConversation?.selectedMessage?.session ?? MSSession()
        let message = MSMessage(session: session)
        let layout = MSMessageTemplateLayout()
        
        let urlContents = parseURL()
        var groupName = URLQueryItem(name: "groupName", value: urlContents!["groupName"])
        let groupSize = URLQueryItem(name: "groupSize", value: urlContents!["groupSize"])
        let date = URLQueryItem(name: "date", value: urlContents!["date"])
        let numJoined = urlContents!.count - 3 + 1
        
        
        if String(numJoined) == groupSize.value {
            layout.caption = "\(groupName.value ?? "Your group") is Full!"
            layout.subcaption = "Tap to become a Secret Santa!"
            message.layout = layout
            let user:String = self.activeConversation?.localParticipantIdentifier.uuidString ?? "Unknown"
            var qUser = URLQueryItem(name: user, value: joinName)
            var friends = Array<URLQueryItem>()
            var SSDictionary = [String:String]()
            for entry in urlContents! {
                if entry.key != "groupName" && entry.key != "groupSize" && entry.key != "date" {
                    let friend = URLQueryItem(name: entry.key, value: entry.value)
                    friends.append(friend)
                    SSDictionary[entry.key] = entry.value
                }
            }
            SSDictionary[user] = joinName
            SSDictionary = assignSecretSantas(members: SSDictionary)
            for i in stride(from: 0, to: friends.count, by: 1) {
                friends[i].value = "\(friends[i].value ?? ""):\(SSDictionary[friends[i].name] ?? "")"
            }
            qUser.value = "\(qUser.value ?? ""):\(SSDictionary[qUser.name] ?? "")"
            var components = URLComponents()
            components.queryItems = [groupName, groupSize, date]
            for friend in friends {
                components.queryItems?.append(friend)
            }
            components.queryItems?.append(qUser)
            message.url = components.url
            self.activeConversation?.insert(message, completionHandler: { (e:Error?) in print("complete!") })
            self.dismiss()
        }
        else {
            layout.caption = "Tap to join " + groupName.value!
            layout.subcaption = "\(numJoined)/\(groupSize.value ?? "0") Group Members Joined"
            message.layout = layout
            let user:String = self.activeConversation?.localParticipantIdentifier.uuidString ?? "Unknown"
            let qUser = URLQueryItem(name: user, value: joinName)
            var friends = Array<URLQueryItem>()
            for entry in urlContents! {
                if entry.key != "groupName" && entry.key != "groupSize" && entry.key != "date" {
                    let friend = URLQueryItem(name: entry.key, value: entry.value)
                    friends.append(friend)
                }
            }
            var components = URLComponents()
            components.queryItems = [groupName, groupSize, date]
            for friend in friends {
                components.queryItems?.append(friend)
            }
            components.queryItems?.append(qUser)
            message.url = components.url
            self.activeConversation?.insert(message, completionHandler: { (e:Error?) in print("complete!") })
            self.dismiss()
        }
    }
    
    // Convert message's URLComponents into Dictionary of Strings
    func parseURL() -> [String:String]? {
        var result: [String:String] = [:]
        if let tempURL = self.activeConversation?.selectedMessage?.url {
            let components = URLComponents(url: tempURL, resolvingAgainstBaseURL: false)!
            for item in components.queryItems! {
                result[item.name] = item.value!
            }
            return result
        }
        return nil
    }
    
    
    func getPreviousURL() -> URL? {
        if let url:URL = self.activeConversation?.selectedMessage?.url {
            return url
        }
        return nil
    }
    
    
    // Assign Secret Santas before sending message, so that everyone gets the same "roll"
    func assignSecretSantas(members: [String:String]) -> [String:String] {
        var result: [String:String] = [:]
        var namesInHat = Array<String>()
        for member in members {
            namesInHat.append(member.key)
        }
        
        /* Rarely it's possible that someone can be left with only their own name left in the hat
           e.g. Person A picks Person B
                Person B picks Person A
                Person C is left with only their own name.
           However, it is always possible to get a proper assignment, so spin until one is found. */
        var tempNamesInHat = namesInHat
        var someoneChoseSelf = true
        while (someoneChoseSelf) {
            for chooser in members {
                var index = -1
                if tempNamesInHat.count == 1 {
                    index = 0
                }
                else {
                    var choseSelf = true
                    while (choseSelf) {
                        let random = Int.random(in: 0..<(tempNamesInHat.count))
                        if tempNamesInHat[random] != chooser.key {
                            choseSelf = false
                            index = random
                        }
                    }
                }
                result["\(chooser.key)"] = tempNamesInHat[index]
                tempNamesInHat.remove(at: index)
            }
            someoneChoseSelf = false
            for member in members {
                if result[member.key] == member.key {
                    // i.e. Someone chose self
                    someoneChoseSelf = true
                    // Refill hat
                    tempNamesInHat = namesInHat
                }
            }
        }
        
        return result
    }
 
    func getLocalUUIDString() -> String {
        return self.activeConversation?.localParticipantIdentifier.uuidString ?? "Unknown"
    }
    
}
